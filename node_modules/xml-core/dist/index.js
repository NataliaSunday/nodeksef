'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const ELEMENT = "element";
const ATTRIBUTE = "attribute";
const CONTENT = "content";

const MAX = 1e9;
function assign$1(target, ...sources) {
    const res = arguments[0];
    for (let i = 1; i < arguments.length; i++) {
        const obj = arguments[i];
        for (const prop in obj) {
            if (!obj.hasOwnProperty(prop)) {
                continue;
            }
            res[prop] = obj[prop];
        }
    }
    return res;
}
function XmlElement(params) {
    return (target) => {
        const t = target;
        t.localName = params.localName || t.name;
        t.namespaceURI = params.namespaceURI || t.namespaceURI || null;
        t.prefix = params.prefix || t.prefix || null;
        t.parser = params.parser || t.parser;
        if (t.target !== t) {
            t.items = assign$1({}, t.items);
        }
        t.target = target;
    };
}
function XmlChildElement(params = {}) {
    return (target, propertyKey) => {
        const t = target.constructor;
        const key = propertyKey;
        if (!t.items) {
            t.items = {};
        }
        if (t.target !== t) {
            t.items = assign$1({}, t.items);
        }
        t.target = target;
        if (params.parser) {
            t.items[key] = {
                parser: params.parser,
                required: params.required || false,
                maxOccurs: params.maxOccurs || MAX,
                minOccurs: params.minOccurs === void 0 ? 0 : params.minOccurs,
                noRoot: params.noRoot || false,
            };
        }
        else {
            t.items[key] = {
                namespaceURI: params.namespaceURI || null,
                required: params.required || false,
                prefix: params.prefix || null,
                defaultValue: params.defaultValue,
                converter: params.converter,
                noRoot: params.noRoot || false,
            };
        }
        params.localName = params.localName || (params.parser && params.parser.localName) || key;
        t.items[key].namespaceURI = params.namespaceURI || (params.parser && params.parser.namespaceURI) || null;
        t.items[key].prefix = params.prefix || (params.parser && params.parser.prefix) || null;
        t.items[key].localName = params.localName;
        t.items[key].type = ELEMENT;
        defineProperty(target, key, params);
    };
}
function XmlAttribute(params = { required: false, namespaceURI: null }) {
    return (target, propertyKey) => {
        const t = target.constructor;
        const key = propertyKey;
        if (!params.localName) {
            params.localName = propertyKey;
        }
        if (!t.items) {
            t.items = {};
        }
        if (t.target !== t) {
            t.items = assign$1({}, t.items);
        }
        t.target = target;
        t.items[propertyKey] = params;
        t.items[propertyKey].type = ATTRIBUTE;
        defineProperty(target, key, params);
    };
}
function XmlContent(params = { required: false }) {
    return (target, propertyKey) => {
        const t = target.constructor;
        const key = propertyKey;
        if (!t.items) {
            t.items = {};
        }
        if (t.target !== t) {
            t.items = assign$1({}, t.items);
        }
        t.target = target;
        t.items[propertyKey] = params;
        t.items[propertyKey].type = CONTENT;
        defineProperty(target, key, params);
    };
}
function defineProperty(target, key, params) {
    const key2 = `_${key}`;
    const opt = {
        set: function (v) {
            if (this[key2] !== v) {
                this.element = null;
                this[key2] = v;
            }
        },
        get: function () {
            if (this[key2] === void 0) {
                let defaultValue = params.defaultValue;
                if (params.parser) {
                    defaultValue = new params.parser();
                    defaultValue.localName = params.localName;
                }
                this[key2] = defaultValue;
            }
            return this[key2];
        },
    };
    Object.defineProperty(target, key2, { writable: true, enumerable: false });
    Object.defineProperty(target, key, opt);
}

class Collection {
    constructor(items) {
        this.items = new Array();
        if (items) {
            this.items = items;
        }
    }
    get Count() {
        return this.items.length;
    }
    Item(index) {
        return this.items[index] || null;
    }
    Add(item) {
        this.items.push(item);
    }
    Pop() {
        return this.items.pop();
    }
    RemoveAt(index) {
        this.items = this.items.filter((item, index2) => index2 !== index);
    }
    Clear() {
        this.items = new Array();
    }
    GetIterator() {
        return this.items;
    }
    ForEach(cb) {
        this.GetIterator().forEach(cb);
    }
    Map(cb) {
        return new Collection(this.GetIterator().map(cb));
    }
    Filter(cb) {
        return new Collection(this.GetIterator().filter(cb));
    }
    Sort(cb) {
        return new Collection(this.GetIterator().sort(cb));
    }
    Every(cb) {
        return this.GetIterator().every(cb);
    }
    Some(cb) {
        return this.GetIterator().some(cb);
    }
    IsEmpty() {
        return this.Count === 0;
    }
}

function printf(text, ...args) {
    let msg = text;
    const regFind = /[^%](%\d+)/g;
    let match = null;
    const matches = [];
    while (match = regFind.exec(msg)) {
        matches.push({ arg: match[1], index: match.index });
    }
    for (let i = matches.length - 1; i >= 0; i--) {
        const item = matches[i];
        const arg = item.arg.substring(1);
        const index = item.index + 1;
        msg = msg.substring(0, index) + arguments[+arg] + msg.substring(index + 1 + arg.length);
    }
    msg = msg.replace("%%", "%");
    return msg;
}
function padNum(num, size) {
    let s = num + "";
    while (s.length < size) {
        s = "0" + s;
    }
    return s;
}
class XmlError {
    constructor(code, ...args) {
        this.prefix = "XMLJS";
        this.code = code;
        this.name = this.constructor.name;
        arguments[0] = xes[code];
        const message = printf.apply(this, arguments);
        this.message = `${this.prefix}${padNum(code, 4)}: ${message}`;
        this.stack = new Error(this.message).stack;
    }
}
exports.XE = void 0;
(function (XE) {
    XE[XE["NONE"] = 0] = "NONE";
    XE[XE["NULL_REFERENCE"] = 1] = "NULL_REFERENCE";
    XE[XE["NULL_PARAM"] = 2] = "NULL_PARAM";
    XE[XE["DECORATOR_NULL_PARAM"] = 3] = "DECORATOR_NULL_PARAM";
    XE[XE["COLLECTION_LIMIT"] = 4] = "COLLECTION_LIMIT";
    XE[XE["METHOD_NOT_IMPLEMENTED"] = 5] = "METHOD_NOT_IMPLEMENTED";
    XE[XE["METHOD_NOT_SUPPORTED"] = 6] = "METHOD_NOT_SUPPORTED";
    XE[XE["PARAM_REQUIRED"] = 7] = "PARAM_REQUIRED";
    XE[XE["CONVERTER_UNSUPPORTED"] = 8] = "CONVERTER_UNSUPPORTED";
    XE[XE["ELEMENT_MALFORMED"] = 9] = "ELEMENT_MALFORMED";
    XE[XE["ELEMENT_MISSING"] = 10] = "ELEMENT_MISSING";
    XE[XE["ATTRIBUTE_MISSING"] = 11] = "ATTRIBUTE_MISSING";
    XE[XE["CONTENT_MISSING"] = 12] = "CONTENT_MISSING";
    XE[XE["CRYPTOGRAPHIC"] = 13] = "CRYPTOGRAPHIC";
    XE[XE["CRYPTOGRAPHIC_NO_MODULE"] = 14] = "CRYPTOGRAPHIC_NO_MODULE";
    XE[XE["CRYPTOGRAPHIC_UNKNOWN_TRANSFORM"] = 15] = "CRYPTOGRAPHIC_UNKNOWN_TRANSFORM";
    XE[XE["ALGORITHM_NOT_SUPPORTED"] = 16] = "ALGORITHM_NOT_SUPPORTED";
    XE[XE["ALGORITHM_WRONG_NAME"] = 17] = "ALGORITHM_WRONG_NAME";
    XE[XE["XML_EXCEPTION"] = 18] = "XML_EXCEPTION";
})(exports.XE || (exports.XE = {}));
const xes = {};
xes[exports.XE.NONE] = "No description";
xes[exports.XE.NULL_REFERENCE] = "Null reference";
xes[exports.XE.NULL_PARAM] = "'%1' has empty '%2' object";
xes[exports.XE.DECORATOR_NULL_PARAM] = "Decorator '%1' has empty '%2' parameter";
xes[exports.XE.COLLECTION_LIMIT] = "Collection of '%1' in element '%2' has wrong amount of items";
xes[exports.XE.METHOD_NOT_IMPLEMENTED] = "Method is not implemented";
xes[exports.XE.METHOD_NOT_SUPPORTED] = "Method is not supported";
xes[exports.XE.PARAM_REQUIRED] = "Required parameter is missing '%1'";
xes[exports.XE.CONVERTER_UNSUPPORTED] = "Converter is not supported";
xes[exports.XE.ELEMENT_MALFORMED] = "Malformed element '%1'";
xes[exports.XE.ELEMENT_MISSING] = "Element '%1' is missing in '%2'";
xes[exports.XE.ATTRIBUTE_MISSING] = "Attribute '%1' is missing in '%2'";
xes[exports.XE.CONTENT_MISSING] = "Content is missing in '%1'";
xes[exports.XE.CRYPTOGRAPHIC] = "Cryptographic error: %1";
xes[exports.XE.CRYPTOGRAPHIC_NO_MODULE] = "WebCrypto module is not found";
xes[exports.XE.CRYPTOGRAPHIC_UNKNOWN_TRANSFORM] = "Unknown transform %1";
xes[exports.XE.ALGORITHM_NOT_SUPPORTED] = "Algorithm is not supported '%1'";
xes[exports.XE.ALGORITHM_WRONG_NAME] = "Algorithm wrong name in use '%1'";
xes[exports.XE.XML_EXCEPTION] = "XML exception: %1";

class Convert {
    static ToString(buffer, enc = "utf8") {
        const buf = new Uint8Array(buffer);
        switch (enc.toLowerCase()) {
            case "utf8":
                return this.ToUtf8String(buf);
            case "binary":
                return this.ToBinary(buf);
            case "hex":
                return this.ToHex(buf);
            case "base64":
                return this.ToBase64(buf);
            case "base64url":
                return this.ToBase64Url(buf);
            default:
                throw new XmlError(exports.XE.CONVERTER_UNSUPPORTED);
        }
    }
    static FromString(str, enc = "utf8") {
        switch (enc.toLowerCase()) {
            case "utf8":
                return this.FromUtf8String(str);
            case "binary":
                return this.FromBinary(str);
            case "hex":
                return this.FromHex(str);
            case "base64":
                return this.FromBase64(str);
            case "base64url":
                return this.FromBase64Url(str);
            default:
                throw new XmlError(exports.XE.CONVERTER_UNSUPPORTED);
        }
    }
    static ToBase64(buf) {
        if (typeof btoa !== "undefined") {
            const binary = this.ToString(buf, "binary");
            return btoa(binary);
        }
        else if (typeof Buffer !== "undefined") {
            return Buffer.from(buf).toString("base64");
        }
        else {
            throw new XmlError(exports.XE.CONVERTER_UNSUPPORTED);
        }
    }
    static FromBase64(base64Text) {
        base64Text = base64Text.replace(/\n/g, "").replace(/\r/g, "").replace(/\t/g, "").replace(/\s/g, "");
        if (typeof atob !== "undefined") {
            return this.FromBinary(atob(base64Text));
        }
        else if (typeof Buffer !== "undefined") {
            return new Uint8Array(Buffer.from(base64Text, "base64"));
        }
        else {
            throw new XmlError(exports.XE.CONVERTER_UNSUPPORTED);
        }
    }
    static FromBase64Url(base64url) {
        return this.FromBase64(this.Base64Padding(base64url.replace(/\-/g, "+").replace(/\_/g, "/")));
    }
    static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    }
    static FromUtf8String(text) {
        const s = unescape(encodeURIComponent(text));
        const uintArray = new Uint8Array(s.length);
        for (let i = 0; i < s.length; i++) {
            uintArray[i] = s.charCodeAt(i);
        }
        return uintArray;
    }
    static ToUtf8String(buffer) {
        const encodedString = String.fromCharCode.apply(null, buffer);
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
    }
    static FromBinary(text) {
        const stringLength = text.length;
        const resultView = new Uint8Array(stringLength);
        for (let i = 0; i < stringLength; i++) {
            resultView[i] = text.charCodeAt(i);
        }
        return resultView;
    }
    static ToBinary(buffer) {
        let resultString = "";
        for (let i = 0; i < buffer.length; i++) {
            resultString = resultString + String.fromCharCode(buffer[i]);
        }
        return resultString;
    }
    static ToHex(buffer) {
        const splitter = "";
        const res = [];
        for (let i = 0; i < buffer.length; i++) {
            const char = buffer[i].toString(16);
            res.push(char.length === 1 ? "0" + char : char);
        }
        return res.join(splitter);
    }
    static FromHex(hexString) {
        const res = new Uint8Array(hexString.length / 2);
        for (let i = 0; i < hexString.length; i = i + 2) {
            const c = hexString.slice(i, i + 2);
            res[i / 2] = parseInt(c, 16);
        }
        return res;
    }
    static ToDateTime(dateTime) {
        return new Date(dateTime);
    }
    static FromDateTime(dateTime) {
        const str = dateTime.toISOString();
        return str;
    }
    static Base64Padding(base64) {
        const padCount = 4 - (base64.length % 4);
        if (padCount < 4) {
            for (let i = 0; i < padCount; i++) {
                base64 += "=";
            }
        }
        return base64;
    }
}

const APPLICATION_XML = "application/xml";
const DEFAULT_PREFIX = "";
const DEFAULT_NAMESPACE_URI = "";
exports.XmlNodeType = void 0;
(function (XmlNodeType) {
    XmlNodeType[XmlNodeType["None"] = 0] = "None";
    XmlNodeType[XmlNodeType["Element"] = 1] = "Element";
    XmlNodeType[XmlNodeType["Attribute"] = 2] = "Attribute";
    XmlNodeType[XmlNodeType["Text"] = 3] = "Text";
    XmlNodeType[XmlNodeType["CDATA"] = 4] = "CDATA";
    XmlNodeType[XmlNodeType["EntityReference"] = 5] = "EntityReference";
    XmlNodeType[XmlNodeType["Entity"] = 6] = "Entity";
    XmlNodeType[XmlNodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    XmlNodeType[XmlNodeType["Comment"] = 8] = "Comment";
    XmlNodeType[XmlNodeType["Document"] = 9] = "Document";
    XmlNodeType[XmlNodeType["DocumentType"] = 10] = "DocumentType";
    XmlNodeType[XmlNodeType["DocumentFragment"] = 11] = "DocumentFragment";
    XmlNodeType[XmlNodeType["Notation"] = 12] = "Notation";
    XmlNodeType[XmlNodeType["Whitespace"] = 13] = "Whitespace";
    XmlNodeType[XmlNodeType["SignificantWhitespace"] = 14] = "SignificantWhitespace";
    XmlNodeType[XmlNodeType["EndElement"] = 15] = "EndElement";
    XmlNodeType[XmlNodeType["EndEntity"] = 16] = "EndEntity";
    XmlNodeType[XmlNodeType["XmlDeclaration"] = 17] = "XmlDeclaration";
})(exports.XmlNodeType || (exports.XmlNodeType = {}));

let xpath = (node, xPath) => {
    throw new Error("Not implemented");
};
let sWindow;
if (typeof self === "undefined") {
    sWindow = global;
    const xmldom = require("@xmldom/xmldom");
    xpath = require("xpath.js");
    sWindow.XMLSerializer = xmldom.XMLSerializer;
    sWindow.DOMParser = xmldom.DOMParser;
    sWindow.DOMImplementation = xmldom.DOMImplementation;
    sWindow.document = new DOMImplementation().createDocument("http://www.w3.org/1999/xhtml", "html", null);
}
else {
    sWindow = self;
}
function SelectNodesEx(node, xPath) {
    const doc = node.ownerDocument == null ? node : node.ownerDocument;
    const nsResolver = document.createNSResolver(node.ownerDocument == null ? node.documentElement : node.ownerDocument.documentElement);
    const personIterator = doc.evaluate(xPath, node, nsResolver, XPathResult.ANY_TYPE, null);
    const ns = [];
    let n;
    while (n = personIterator.iterateNext()) {
        ns.push(n);
    }
    return ns;
}
const Select = (typeof self !== "undefined") ? SelectNodesEx : xpath;
function Parse(xmlString) {
    xmlString = xmlString
        .replace(/\r\n/g, "\n")
        .replace(/\r/g, "\n");
    return new DOMParser().parseFromString(xmlString, APPLICATION_XML);
}
function Stringify(target) {
    return new XMLSerializer().serializeToString(target);
}
function SelectSingleNode(node, path) {
    const ns = Select(node, path);
    if (ns && ns.length > 0) {
        return ns[0];
    }
    return null;
}
function _SelectNamespaces(node, selectedNodes = {}) {
    if (isElement(node)) {
        if (node.namespaceURI && node.namespaceURI !== "http://www.w3.org/XML/1998/namespace" && !selectedNodes[node.prefix || ""]) {
            selectedNodes[node.prefix ? node.prefix : ""] = node.namespaceURI;
        }
        for (let i = 0; i < node.childNodes.length; i++) {
            const childNode = node.childNodes.item(i);
            if (childNode && childNode.nodeType === exports.XmlNodeType.Element) {
                _SelectNamespaces(childNode, selectedNodes);
            }
        }
    }
}
function SelectNamespaces(node) {
    const attrs = {};
    _SelectNamespaces(node, attrs);
    return attrs;
}
function assign(target, ...sources) {
    const res = arguments[0];
    for (let i = 1; i < arguments.length; i++) {
        const obj = arguments[i];
        for (const prop in obj) {
            if (!obj.hasOwnProperty(prop)) {
                continue;
            }
            res[prop] = obj[prop];
        }
    }
    return res;
}
function isNodeType(obj, type) {
    return obj && obj.nodeType === type;
}
function isElement(obj) {
    return isNodeType(obj, exports.XmlNodeType.Element);
}
function isDocument(obj) {
    return isNodeType(obj, exports.XmlNodeType.Document);
}

const XmlBase64Converter = {
    get: (value) => {
        if (value) {
            return Convert.ToBase64(value);
        }
        return void 0;
    },
    set: (value) => {
        return Convert.FromBase64(value);
    },
};
const XmlNumberConverter = {
    get: (value) => {
        if (value) {
            return value.toString();
        }
        return "0";
    },
    set: (value) => {
        return Number(value);
    },
};
const XmlBooleanConverter = {
    get: (value) => {
        if (value) {
            return value.toString();
        }
        return "false";
    },
    set: (value) => {
        if (value && value.toLowerCase() === "true") {
            return true;
        }
        else {
            return false;
        }
    },
};

const DEFAULT_ROOT_NAME = "xml_root";
class XmlObject {
    constructor(properties = {}) {
        this.prefix = this.GetStatic().prefix || null;
        this.localName = this.GetStatic().localName;
        this.namespaceURI = this.GetStatic().namespaceURI;
        if (properties) {
            for (const [key, value] of Object.entries(properties)) {
                if (value !== undefined) {
                    this[key] = value;
                }
            }
        }
    }
    static LoadXml(param) {
        const xml = new this();
        xml.LoadXml(param);
        return xml;
    }
    static GetElement(element, name, required = true) {
        const xmlNodeList = element.getElementsByTagName(name);
        if (required && xmlNodeList.length === 0) {
            throw new XmlError(exports.XE.ELEMENT_MISSING, name, element.localName);
        }
        return xmlNodeList[0] || null;
    }
    static GetAttribute(element, attrName, defaultValue, required = true) {
        if (element.hasAttribute(attrName)) {
            return element.getAttribute(attrName);
        }
        else {
            if (required) {
                throw new XmlError(exports.XE.ATTRIBUTE_MISSING, attrName, element.localName);
            }
            return defaultValue;
        }
    }
    static GetElementById(node, idValue) {
        if ((node == null) || (idValue == null)) {
            return null;
        }
        let xel = null;
        if (isDocument(node)) {
            xel = node.getElementById(idValue);
        }
        if (xel == null) {
            xel = SelectSingleNode(node, `//*[@Id='${idValue}']`);
            if (xel == null) {
                xel = SelectSingleNode(node, `//*[@ID='${idValue}']`);
                if (xel == null) {
                    xel = SelectSingleNode(node, `//*[@id='${idValue}']`);
                }
            }
        }
        return xel;
    }
    static CreateDocument(root = DEFAULT_ROOT_NAME, namespaceUri = null, prefix = null) {
        let namePrefix = "";
        let nsPrefix = "";
        let namespaceUri2 = "";
        if (prefix) {
            namePrefix = prefix + ":";
            nsPrefix = ":" + prefix;
        }
        if (namespaceUri) {
            namespaceUri2 = ` xmlns${nsPrefix}="${namespaceUri}"`;
        }
        const name = `${namePrefix}${root}`;
        const doc = new DOMParser().parseFromString(`<${name}${namespaceUri2}></${name}>`, APPLICATION_XML);
        return doc;
    }
    static GetChildren(node, localName, nameSpace) {
        node = isDocument(node) ? node.documentElement : node;
        const res = [];
        for (let i = 0; i < node.childNodes.length; i++) {
            const child = node.childNodes[i];
            if (isElement(child) && child.localName === localName && (child.namespaceURI === nameSpace || !nameSpace)) {
                res.push(child);
            }
        }
        return res;
    }
    static GetFirstChild(node, localName, nameSpace) {
        node = isDocument(node) ? node.documentElement : node;
        for (let i = 0; i < node.childNodes.length; i++) {
            const child = node.childNodes[i];
            if (isElement(child) && child.localName === localName && (child.namespaceURI === nameSpace || !nameSpace)) {
                return child;
            }
        }
        return null;
    }
    static GetChild(node, localName, nameSpace, required = true) {
        for (let i = 0; i < node.childNodes.length; i++) {
            const child = node.childNodes[i];
            if (isElement(child) && child.localName === localName && (child.namespaceURI === nameSpace || !nameSpace)) {
                return child;
            }
        }
        if (required) {
            throw new XmlError(exports.XE.ELEMENT_MISSING, localName, node.localName);
        }
        return null;
    }
    get Element() {
        return this.element;
    }
    get Prefix() {
        return this.prefix;
    }
    set Prefix(value) {
        this.prefix = value;
    }
    get LocalName() {
        return this.localName;
    }
    get NamespaceURI() {
        return this.namespaceURI || null;
    }
    HasChanged() {
        const self = this.GetStatic();
        if (self.items) {
            for (const key in self.items) {
                if (!self.items.hasOwnProperty(key)) {
                    continue;
                }
                const item = self.items[key];
                const value = this[key];
                if (item.parser && value && value.HasChanged()) {
                    return true;
                }
            }
        }
        return this.element === null;
    }
    GetXml(hard) {
        if (!(hard || this.HasChanged())) {
            return this.element || null;
        }
        const thisAny = this;
        const doc = this.CreateDocument();
        const el = this.CreateElement();
        const self = this.GetStatic();
        const localName = this.localName;
        if (self.items) {
            for (const key in self.items) {
                if (!self.items.hasOwnProperty(key)) {
                    continue;
                }
                const parser = thisAny[key];
                const selfItem = self.items[key];
                switch (selfItem.type) {
                    case CONTENT: {
                        const schema = selfItem;
                        const value = (schema.converter) ? schema.converter.get(parser) : parser;
                        if (schema.required && (value === null || value === void 0)) {
                            throw new XmlError(exports.XE.CONTENT_MISSING, localName);
                        }
                        if (schema.defaultValue !== parser || schema.required) {
                            el.textContent = value;
                        }
                        break;
                    }
                    case ATTRIBUTE: {
                        const schema = selfItem;
                        const value = (schema.converter) ? schema.converter.get(parser) : parser;
                        if (schema.required && (value === null || value === void 0)) {
                            throw new XmlError(exports.XE.ATTRIBUTE_MISSING, schema.localName, localName);
                        }
                        if (schema.defaultValue !== parser || schema.required) {
                            if (!schema.namespaceURI) {
                                el.setAttribute(schema.localName, value);
                            }
                            else {
                                el.setAttributeNS(schema.namespaceURI, schema.localName, value);
                            }
                        }
                        break;
                    }
                    case ELEMENT: {
                        const schema = selfItem;
                        let node = null;
                        if (schema.parser) {
                            if ((schema.required && !parser) ||
                                (schema.minOccurs && !parser.Count)) {
                                throw new XmlError(exports.XE.ELEMENT_MISSING, parser.localName, localName);
                            }
                            if (parser) {
                                node = parser.GetXml(parser.element === void 0 && (schema.required || parser.Count));
                            }
                        }
                        else {
                            const value = (schema.converter) ? schema.converter.get(parser) : parser;
                            if (schema.required && value === void 0) {
                                throw new XmlError(exports.XE.ELEMENT_MISSING, schema.localName, localName);
                            }
                            if (parser !== schema.defaultValue || schema.required) {
                                if (!schema.namespaceURI) {
                                    node = doc.createElement(`${schema.prefix ? schema.prefix + ":" : ""}${schema.localName}`);
                                }
                                else {
                                    node = doc.createElementNS(schema.namespaceURI, `${schema.prefix ? schema.prefix + ":" : ""}${schema.localName}`);
                                }
                                if (Array.isArray(value)) {
                                    for (const child of value) {
                                        const val = child instanceof XmlObject ?
                                            child.GetXml(true) :
                                            child;
                                        if (val !== null) {
                                            node.appendChild(val);
                                        }
                                    }
                                }
                                else if (value instanceof XmlObject) {
                                    node.appendChild(value.GetXml(true));
                                }
                                else {
                                    node.textContent = value;
                                }
                            }
                        }
                        if (node) {
                            if (schema.noRoot) {
                                const els = [];
                                for (let i = 0; i < node.childNodes.length; i++) {
                                    const colNode = node.childNodes.item(i);
                                    if (isElement(colNode)) {
                                        els.push(colNode);
                                    }
                                }
                                if (els.length < schema.minOccurs || els.length > schema.maxOccurs) {
                                    throw new XmlError(exports.XE.COLLECTION_LIMIT, parser.localName, self.localName);
                                }
                                els.forEach((e) => el.appendChild(e.cloneNode(true)));
                            }
                            else if (node.childNodes.length < schema.minOccurs || node.childNodes.length > schema.maxOccurs) {
                                throw new XmlError(exports.XE.COLLECTION_LIMIT, parser.localName, self.localName);
                            }
                            else {
                                el.appendChild(node);
                            }
                        }
                        break;
                    }
                }
            }
        }
        this.OnGetXml(el);
        this.element = el;
        return el;
    }
    LoadXml(param) {
        let element;
        const thisAny = this;
        if (typeof param === "string") {
            const doc = Parse(param);
            element = doc.documentElement;
        }
        else {
            element = param;
        }
        if (!element) {
            throw new XmlError(exports.XE.PARAM_REQUIRED, "element");
        }
        const self = this.GetStatic();
        const localName = this.localName;
        if (!((element.localName === localName) && (element.namespaceURI == this.NamespaceURI))) {
            throw new XmlError(exports.XE.ELEMENT_MALFORMED, localName);
        }
        if (self.items) {
            for (const key in self.items) {
                if (!self.items.hasOwnProperty(key)) {
                    continue;
                }
                const selfItem = self.items[key];
                switch (selfItem.type) {
                    case CONTENT: {
                        const schema = selfItem;
                        if (schema.required && !element.textContent) {
                            throw new XmlError(exports.XE.CONTENT_MISSING, localName);
                        }
                        if (!element.textContent) {
                            thisAny[key] = schema.defaultValue;
                        }
                        else {
                            const value = schema.converter ? schema.converter.set(element.textContent) : element.textContent;
                            thisAny[key] = value;
                        }
                        break;
                    }
                    case ATTRIBUTE: {
                        const schema = selfItem;
                        let hasAttribute;
                        let getAttribute;
                        if (!schema.localName) {
                            throw new XmlError(exports.XE.PARAM_REQUIRED, "localName");
                        }
                        if (schema.namespaceURI) {
                            hasAttribute = element.hasAttributeNS.bind(element, schema.namespaceURI, schema.localName);
                            getAttribute = element.getAttributeNS.bind(element, schema.namespaceURI, schema.localName);
                        }
                        else {
                            hasAttribute = element.hasAttribute.bind(element, schema.localName);
                            getAttribute = element.getAttribute.bind(element, schema.localName);
                        }
                        if (schema.required && !hasAttribute()) {
                            throw new XmlError(exports.XE.ATTRIBUTE_MISSING, schema.localName, localName);
                        }
                        if (!hasAttribute()) {
                            thisAny[key] = schema.defaultValue;
                        }
                        else {
                            const value = schema.converter ? schema.converter.set(getAttribute()) : getAttribute();
                            thisAny[key] = value;
                        }
                        break;
                    }
                    case ELEMENT: {
                        const schema = selfItem;
                        if (schema.noRoot) {
                            if (!schema.parser) {
                                throw new XmlError(exports.XE.XML_EXCEPTION, `Schema for '${schema.localName}' with flag noRoot must have 'parser'`);
                            }
                            const col = new schema.parser();
                            if (!(col instanceof XmlCollection)) {
                                throw new XmlError(exports.XE.XML_EXCEPTION, `Schema for '${schema.localName}' with flag noRoot must have 'parser' like instance of XmlCollection`);
                            }
                            col.OnLoadXml(element);
                            delete col.element;
                            if (col.Count < schema.minOccurs || col.Count > schema.maxOccurs) {
                                throw new XmlError(exports.XE.COLLECTION_LIMIT, schema.parser.localName, localName);
                            }
                            thisAny[key] = col;
                            continue;
                        }
                        let foundElement = null;
                        for (let i = 0; i < element.childNodes.length; i++) {
                            const node = element.childNodes.item(i);
                            if (!isElement(node)) {
                                continue;
                            }
                            const el = node;
                            if (el.localName === schema.localName &&
                                el.namespaceURI == schema.namespaceURI) {
                                foundElement = el;
                                break;
                            }
                        }
                        if (schema.required && !foundElement) {
                            throw new XmlError(exports.XE.ELEMENT_MISSING, schema.parser ? schema.parser.localName : schema.localName, localName);
                        }
                        if (!schema.parser) {
                            if (!foundElement) {
                                thisAny[key] = schema.defaultValue;
                            }
                            else {
                                const value = schema.converter ? schema.converter.set(foundElement.textContent) : foundElement.textContent;
                                thisAny[key] = value;
                            }
                        }
                        else {
                            if (foundElement) {
                                const value = new schema.parser();
                                value.localName = schema.localName;
                                value.namespaceURI = schema.namespaceURI;
                                thisAny[key] = value;
                                value.LoadXml(foundElement);
                            }
                        }
                        break;
                    }
                }
            }
        }
        this.OnLoadXml(element);
        this.prefix = element.prefix || "";
        this.element = element;
    }
    toString() {
        const xml = this.GetXml();
        return xml ? new XMLSerializer().serializeToString(xml) : "";
    }
    GetElement(name, required = true) {
        if (!this.element) {
            throw new XmlError(exports.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetElement(this.element, name, required);
    }
    GetChildren(localName, nameSpace) {
        if (!this.element) {
            throw new XmlError(exports.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetChildren(this.element, localName, nameSpace || this.NamespaceURI || undefined);
    }
    GetChild(localName, required = true) {
        if (!this.element) {
            throw new XmlError(exports.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetChild(this.element, localName, this.NamespaceURI || undefined, required);
    }
    GetFirstChild(localName, namespace) {
        if (!this.element) {
            throw new XmlError(exports.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetFirstChild(this.element, localName, namespace);
    }
    GetAttribute(name, defaultValue, required = true) {
        if (!this.element) {
            throw new XmlError(exports.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetAttribute(this.element, name, defaultValue, required);
    }
    IsEmpty() {
        return this.Element === void 0;
    }
    OnLoadXml(element) {
    }
    GetStatic() {
        return this.constructor;
    }
    GetPrefix() {
        return (this.Prefix) ? this.prefix + ":" : "";
    }
    OnGetXml(element) {
    }
    CreateElement(document, localName, namespaceUri = null, prefix = null) {
        if (!document) {
            document = this.CreateDocument();
        }
        localName = localName || this.localName;
        namespaceUri = namespaceUri || this.NamespaceURI;
        prefix = prefix || this.prefix;
        const tagName = (prefix ? `${prefix}:` : "") + localName;
        const xn = namespaceUri ? document.createElementNS(namespaceUri, tagName) : document.createElement(tagName);
        document.importNode(xn, true);
        return xn;
    }
    CreateDocument() {
        return XmlObject.CreateDocument(this.localName, this.NamespaceURI, this.Prefix);
    }
}

class XmlCollection extends XmlObject {
    constructor() {
        super(...arguments);
        this.MaxOccurs = Number.MAX_VALUE;
        this.MinOccurs = 0;
        this.items = [];
    }
    HasChanged() {
        const res = super.HasChanged();
        const changed = this.Some((item) => item.HasChanged());
        return res || changed;
    }
    get Count() {
        return this.items.length;
    }
    Item(index) {
        return this.items[index] || null;
    }
    Add(item) {
        this.items.push(item);
        this.element = null;
    }
    Pop() {
        this.element = null;
        return this.items.pop();
    }
    RemoveAt(index) {
        this.items = this.items.filter((item, index2) => index2 !== index);
        this.element = null;
    }
    Clear() {
        this.items = new Array();
        this.element = null;
    }
    GetIterator() {
        return this.items;
    }
    ForEach(cb) {
        this.GetIterator().forEach(cb);
    }
    Map(cb) {
        return new Collection(this.GetIterator().map(cb));
    }
    Filter(cb) {
        return new Collection(this.GetIterator().filter(cb));
    }
    Sort(cb) {
        return new Collection(this.GetIterator().sort(cb));
    }
    Every(cb) {
        return this.GetIterator().every(cb);
    }
    Some(cb) {
        return this.GetIterator().some(cb);
    }
    IsEmpty() {
        return this.Count === 0;
    }
    OnGetXml(element) {
        for (const item of this.GetIterator()) {
            const el = item.GetXml();
            if (el) {
                element.appendChild(el);
            }
        }
    }
    OnLoadXml(element) {
        const self = this.GetStatic();
        if (!self.parser) {
            throw new XmlError(exports.XE.XML_EXCEPTION, `${self.localName} doesn't have required 'parser' in @XmlElement`);
        }
        for (let i = 0; i < element.childNodes.length; i++) {
            const node = element.childNodes.item(i);
            if (!(isElement(node) &&
                node.localName === self.parser.localName &&
                node.namespaceURI == self.namespaceURI)) {
                continue;
            }
            const el = node;
            const item = new self.parser();
            item.LoadXml(el);
            this.Add(item);
        }
    }
}

class NamespaceManager extends Collection {
    Add(item) {
        item.prefix = item.prefix || "";
        item.namespace = item.namespace || "";
        super.Add(item);
    }
    GetPrefix(prefix, start = this.Count - 1) {
        const lim = this.Count - 1;
        prefix = prefix || "";
        if (start > lim) {
            start = lim;
        }
        for (let i = start; i >= 0; i--) {
            const item = this.items[i];
            if (item.prefix === prefix) {
                return item;
            }
        }
        return null;
    }
    GetNamespace(namespaceUrl, start = this.Count - 1) {
        const lim = this.Count - 1;
        namespaceUrl = namespaceUrl || "";
        if (start > lim) {
            start = lim;
        }
        for (let i = start; i >= 0; i--) {
            const item = this.items[i];
            if (item.namespace === namespaceUrl) {
                return item;
            }
        }
        return null;
    }
}

exports.APPLICATION_XML = APPLICATION_XML;
exports.Collection = Collection;
exports.Convert = Convert;
exports.DEFAULT_NAMESPACE_URI = DEFAULT_NAMESPACE_URI;
exports.DEFAULT_PREFIX = DEFAULT_PREFIX;
exports.NamespaceManager = NamespaceManager;
exports.Parse = Parse;
exports.Select = Select;
exports.SelectNamespaces = SelectNamespaces;
exports.SelectSingleNode = SelectSingleNode;
exports.Stringify = Stringify;
exports.XmlAttribute = XmlAttribute;
exports.XmlBase64Converter = XmlBase64Converter;
exports.XmlBooleanConverter = XmlBooleanConverter;
exports.XmlChildElement = XmlChildElement;
exports.XmlCollection = XmlCollection;
exports.XmlContent = XmlContent;
exports.XmlElement = XmlElement;
exports.XmlError = XmlError;
exports.XmlNumberConverter = XmlNumberConverter;
exports.XmlObject = XmlObject;
exports.assign = assign;
exports.isDocument = isDocument;
exports.isElement = isElement;
